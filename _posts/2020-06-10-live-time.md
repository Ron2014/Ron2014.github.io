---
layout: post
title: 跑在01世界中的生命
date: 2020-06-10 09:41
description: 盘点程序中的各种生命周期
toc: true
tags:
 - program
 - livetime
 - thinking
 - learning
---

## 生命周期

生命, 指的是一个对象的诞生到资源的释放.

在量子计算机普及之前, 我们所有能用到的计算机资源都是有限的.

这就导致我们需要采取一些列手段来管理这些资源: 仅在需要时申请, 不需要时交还给操作系统.

在这个过程中, 我们所使用的资源处于激活状态, 于是就有了`生命周期`的概念.

计算机都是围绕机器指令来设计的, 所有的工作都要通过人为的触发.

源码的编译, 内存的使用等等, 都有提供相应的API或者ABI.

## 围绕生命周期的思维模式

有时候我会想, 学习计算机是学习什么?

一门语言的语法, 一份开源库的extern接口定义, 一套图形引擎的按钮?

你会发现:

一门语言的语法和语义, 是由它的编译器或者解释器而决定的. 用这种语言编写的源代码, 对于编译器或者解释器来讲, 如同配置文件一样.

一份开源库的extern接口定义, 也不过是IPO模式下的一部分, 有时候如何读懂它的Output比研究它的输入更加复杂, 甚至会需要数据可视化工具.

一套图形引擎的按钮, 不论是Unity还是Unreal, 很容易陷入这样的学习误区. 难免会碰到一些教程对开发手册的复制粘贴, 毫无营养. 

当然我不是说开发手册没有用处, 我只是强调手册没有重点, 没有顺序. 学习路径的规划依然需要一定的思维方式, 或者说知识结构来规划.

我把这种思维方式定义为:

学习编程, 其实是去了解各种概念的生命周期.

或许我们在了解事物的时候, 都可以向自己提一些一般化的问题:

1. 这个东西, 它用来做什么的? 也就是说: 它存在的目的.
2. 这个东西, 它什么时候是活的(激活状态), 什么时候是死的(资源释放, 不再占用存储空间, 不再需要CPU/GPU计算)? 
3. 这个东西, 它从哪里来, 又最终成为了什么? 有些变换不一定要求可逆, 如源码编译成二进制. 只能说, 数据经过处理之后, 以另外一种形式存在. 像极了计算机科学中的'能量守恒'.
4. 这个东西, 除了生死之外, 还有没有别的状态? 如挂起, 排队, 等待, 暂停和唤醒, 作用域等.
5. 这个东西, 如果量很多的话, 应该如何管理, 如何优化? 就好比人口爆炸, 划分了不同地理位置\不同职能部门管理一样. 简单来说, 就是: 这玩意有没有"池", 或者比"池"更高级的规模化管理机制.
6. 一个完整的流程图去解释这个东西的一生. 以及在流程中, 每个步骤的功能(存在的意义).

不出意外的话, 能称之为'机制' '架构' '工具' '系统' 的东西都逃不开这几个方面的思考.

我们常常接触的语法和API式的思维模式, 只是把大量的精力放在问题2上: 一个变量的定义和不定义, 一个函数的调用和不调用. 这种思维方式没有任何逻辑串联.

但相信我, 它是做什么的, 它会经历多少个环节, 每个环节可能会遇到怎样的问题从而导致我该如何去管理它, 才是理解它的重头戏. 也就是上面的问题165.

那就让我们开始吧:

本篇主要用于收集各种`生命周期`相关的理论和实验.

## 编译原理: 一行源码的生命

## 内存管理: 一块内存的生命

### TCMalloc
### jemalloc

## 垃圾回收: 一个GC对象的生命

### lua 的垃圾回收机制
#### lua 不同版本的垃圾回收的变化

### python 的垃圾回收机制
### C# 的垃圾回收机制

## 并发机制: 一个线程的生命

## 网络链接: 一条链接的生命

## 网络传输: 一封信息的生命

## 渲染管线: 一个像素的生命